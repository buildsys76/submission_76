import pandas as pd
import numpy as np

# Initialize an empty DataFrame to store the electricity consumption data
df = pd.DataFrame(columns=['Date', 'Value'])

# Calculate the number of measurements per month based on the total number of measurements and days in a year
days_in_year = 365.25  # Accounting for leap years
total_measurements = 432
measurements_per_month = total_measurements // 12
measurements_per_day = (total_measurements % 12)

# Set the start date and end date
start_date = '01-01-2016'
end_date = f'31-{start_date.split("-")[1]}-{start_date.split("-")[2]}'

# Generate dates from the start date to the end date with a time interval of 1 hour
dates = pd.date_range(start=start_date, end=end_date, freq='H')

# Create a copy of the dates DataFrame for easier manipulation
df_dates = df.copy()
df_dates['Date'] = dates

# Add NaN values at the beginning and end of the DataFrame to match the number of measurements
df = pd.concat([pd.NAN, df_dates, pd.NAN], ignore_index=True)

# Set the value column as a pandas Series
df['Value'] = np.nan

# Iterate over each month in the year
for i in range(1, 13):
    # Calculate the start and end dates for the current month
    if i == 12:  # For December, consider it part of both the current and next year
        month_start_date = f'01-{start_date.split("-")[1]}-{start_date.split("-")[2]}'
        month_end_date = f'31-12-{start_date.split("-")[2]}'
    else:
        month_start_date = f'01-{i:02d}-01'
        month_end_date = f'28-{i:02d}-31'

    # Generate dates for the current month
    if measurements_per_day > 0:
        month_dates = pd.date_range(start=month_start_date, end=month_end_date, freq='D').iloc[:measurements_per_day]
    else:
        month_dates = pd.date_range(start=month_start_date, end=month_end_date, freq='H')

    # Randomly select measurements for each hour in the current month
    monthly_measurements = df['Value'].loc[dates[(dates >= month_start_date) & (dates <= month_end_date)]].sample(size=len(month_dates)).values

    # Replace NaN values with randomly selected measurements and add to the DataFrame
    df.loc[(df['Date'] >= month_start_date) & (df['Date'] <= month_end_date), 'Value'] = monthly_measurements

# Ensure that the lowest possible value is reached at the start of the dataset
if np.nan in df['Value'].values:
    lowest_value = df['Value'].loc[np.nan].min()
else:
    lowest_value = df['Value'].iloc[0]

# Ensure that the highest possible value is reached at the end of the dataset
df.loc[df['Date'] == pd.to_datetime('01-08-2016').date(), 'Value'] = df['Value'].max()

# Add more realistic values to ensure they are near yearly_mean_kwh and never exceed yearly_max_kwh or go below yearly_min_kwh

# Define the possible monthly averages
possible_monthly_averages = [15, 20, 22, 20, 18, 17, 16, 19, 21, 20, 22, 20]

# Generate dates for each day in June, July, and August
summer_dates = pd.date_range(start='01-06-2016', end='31-08-2016', freq='D')

# Generate the data for these months using a normal distribution to ensure it averages around summer_mean_kwh
for date in summer_dates:
    df.loc[date, 'Value'] = np.random.normal(summer_mean_kwh, yearly_max_kwh/100)

# Repeat this process for December, January, February

# Add more realistic values for other months based on the possible monthly averages and normal distribution 
for month_start_date in ['01-02-2016', '01-03-2016', '01-04-2016', '01-05-2016']:
    summer_dates = pd.date_range(start=month_start_date, end='31-08-2016', freq='D')
    for date in summer_dates:
        df.loc[date, 'Value'] = np.random.normal(summer_mean_kwh, yearly_max_kwh/100)

    winter_dates = pd.date_range(start='01-11-2015', end=month_start_date, freq='D')
    for date in winter_dates:
        df.loc[date, 'Value'] = np.random.normal(winter_mean_kwh, yearly_max_kwh/100)

# Remove the rows with NaN values
df.dropna(inplace=True)

for i in range(len(df)):
    if df['Date'].iloc[i] < pd.to_datetime('01-08-2016'):
        df['Value'].iloc[i] = np.random.normal(winter_mean_kwh, yearly_max_kwh/100)
    else:
        df['Value'].iloc[i] = np.random.normal(summer_mean_kwh, yearly_max_kwh/100)

for i in range(len(df)):
    if df['Date'].iloc[i] < pd.to_datetime('01-02-2016'):
        df['Value'].iloc[i] = possible_monthly_averages[np.random.randint(0, 11)]
    else:
        df['Value'].iloc[i] = np.random.normal(summer_mean_kwh, yearly_max_kwh/100)

# Fill in the NaN value at the beginning of the dataset with a value near yearly_min_kwh
if np.nan in df['Value']:
    df.loc[df['Date'] == pd.to_datetime('01-01-2016').date(), 'Value'] = 1.3 * yearly_mean_kwh

print(df)